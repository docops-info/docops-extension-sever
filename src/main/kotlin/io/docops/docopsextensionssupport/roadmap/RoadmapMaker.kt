package io.docops.docopsextensionssupport.roadmap

import io.docops.docopsextensionssupport.svgsupport.escapeXml
import java.text.SimpleDateFormat

/**
 * RoadmapMaker generates SVG visualizations for feature-focused roadmaps
 * showing timeline, quarters, and feature cards with status indicators
 */
class RoadmapMaker {
    
    private val dateFormat = SimpleDateFormat("yyyy-MM-dd")
    private val displayDateFormat = SimpleDateFormat("MMM dd")

    fun generateRoadmapSVG(config: RoadmapConfig, features: List<RoadmapFeature>): String {
        val width = config.width
        val height = config.height
        val svg = StringBuilder()

        // SVG header
        svg.append("""
        <?xml version="1.0" encoding="UTF-8"?>
        <svg xmlns="http://www.w3.org/2000/svg" width="$width" height="$height" viewBox="0 0 $width $height">
    """.trimIndent())

        // Add metadata
        svg.append("""
        <metadata>
            <rdf:rdf xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:cc="http://creativecommons.org/ns#">
                <cc:work rdf:about="">
                    <dc:creator>DocOps.io</dc:creator>
                    <dc:rights>MIT License</dc:rights>
                    <dc:source>https://docops.io</dc:source>
                    <dc:date>2025-07-08</dc:date>
                </cc:work>
            </rdf:rdf>
        </metadata>
        <desc>Generated by DocOps.io - Licensed under MIT License</desc>
    """.trimIndent())

        // Add definitions (gradients, filters, etc.)
        svg.append(generateDefinitions(config))

        // Background
        svg.append("""
        <rect width="$width" height="$height" fill="url(#bgGradient)"/>
    """.trimIndent())

        // Header
        svg.append(generateHeader(config))

        // Timeline and quarters
        svg.append(generateTimeline(config))

        // Feature cards - this is the important part
        val featureCardsSection = generateFeatureCards(config, features)
        svg.append(featureCardsSection)

        // Legend
        if (config.showLegend) {
            svg.append(generateLegend(config))
        }

        // Embedded styles
        svg.append(generateStyles(config))

        svg.append("</svg>")

        return svg.toString()
    }

    private fun generateDefinitions(config: RoadmapConfig): String {
        val defs = StringBuilder()
        
        defs.append("<defs>")
        
        // Category gradients
        config.categories.forEach { (key, category) ->
            if (category.visible) {
                defs.append("""
                    <linearGradient id="${key}Gradient" x1="0%" y1="0%" x2="0%" y2="100%">
                        <stop offset="0%" style="stop-color:${category.color};stop-opacity:1" />
                        <stop offset="100%" style="stop-color:${darkenColor(category.color, 0.2)};stop-opacity:1" />
                    </linearGradient>
                """.trimIndent())
            }
        }
        
        // Background gradient
        defs.append("""
            <linearGradient id="bgGradient" x1="0%" y1="0%" x2="0%" y2="100%">
                <stop offset="0%" style="stop-color:${config.displayConfig.backgroundColor};stop-opacity:1" />
                <stop offset="100%" style="stop-color:${lightenColor(config.displayConfig.backgroundColor, 0.1)};stop-opacity:1" />
            </linearGradient>
        """.trimIndent())
        
        // Timeline gradient
        defs.append("""
            <linearGradient id="timelineGradient" x1="0%" y1="0%" x2="100%" y2="0%">
                <stop offset="0%" style="stop-color:#e5e7eb;stop-opacity:1" />
                <stop offset="40%" style="stop-color:#3b82f6;stop-opacity:1" />
                <stop offset="100%" style="stop-color:#e5e7eb;stop-opacity:1" />
            </linearGradient>
        """.trimIndent())
        
        // Filters
        defs.append("""
            <filter id="cardShadow" x="-50%" y="-50%" width="200%" height="200%">
                <feGaussianBlur in="SourceAlpha" stdDeviation="4"/>
                <feOffset dx="0" dy="6" result="offset" />
                <feComponentTransfer>
                    <feFuncA type="linear" slope="0.2"/>
                </feComponentTransfer>
                <feMerge> 
                    <feMergeNode/>
                    <feMergeNode in="SourceGraphic"/> 
                </feMerge>
            </filter>
            
            <filter id="glow" x="-50%" y="-50%" width="200%" height="200%">
                <feGaussianBlur stdDeviation="3" result="coloredBlur"/>
                <feMerge>
                    <feMergeNode in="coloredBlur"/>
                    <feMergeNode in="SourceGraphic"/>
                </feMerge>
            </filter>
        """.trimIndent())
        
        defs.append("</defs>")
        
        return defs.toString()
    }
    
    private fun generateHeader(config: RoadmapConfig): String {
        val titleY = 50 * config.displayConfig.scale
        val subtitleY = 75 * config.displayConfig.scale
        
        return """
            <text x="50" y="$titleY" class="roadmap-title">${config.title.escapeXml()}</text>
            <text x="50" y="$subtitleY" class="roadmap-subtitle">${config.subtitle.escapeXml()}</text>
        """.trimIndent()
    }

    private fun generateTimeline(config: RoadmapConfig): String {
        val timeline = StringBuilder()

        // Calculate positions dynamically based on number of quarters
        val startX = 100.0
        val columnWidth = 200.0 // Reduced width for more columns
        val timelineWidth = (config.quarters.size - 1) * columnWidth
        val endX = startX + timelineWidth

        // Generate quarter labels positioned above feature card columns
        timeline.append("""<g class="quarters">""")
        config.quarters.forEachIndexed { index, quarter ->
            val x = startX + (index * columnWidth)
            timeline.append("""<text x="$x" y="${120 * config.displayConfig.scale}" class="quarter-label">$quarter</text>""")
        }
        timeline.append("</g>")

        // Generate timeline line
        val timelineY = 140 * config.displayConfig.scale
        timeline.append("""<line x1="$startX" y1="$timelineY" x2="$endX" y2="$timelineY" stroke="url(#timelineGradient)" stroke-width="4"/>""")

        // Generate quarter markers on timeline
        config.quarters.forEachIndexed { index, _ ->
            val x = startX + (index * columnWidth)
            timeline.append("""<circle cx="$x" cy="$timelineY" r="6" fill="#3b82f6"/>""")
        }

        return timeline.toString()
    }

    private fun generateFeatureCards(config: RoadmapConfig, features: List<RoadmapFeature>): String {
        val cards = StringBuilder()

        // Dynamic positioning based on number of quarters
        val startX = 100.0
        val columnWidth = 200.0 // Reduced for more columns
        val cardWidth = 160
        val cardHeight = 120
        val verticalSpacing = 140

        // Group features by quarter
        val featuresByQuarter = features.groupBy { it.quarter }

        config.quarters.forEachIndexed { quarterIndex, quarter ->
            val quarterFeatures = featuresByQuarter[quarter] ?: emptyList()
            val x = startX + (quarterIndex * columnWidth)

            quarterFeatures.forEachIndexed { featureIndex, feature ->
                val y = 180 + (featureIndex * verticalSpacing)
                val cardX = x - (cardWidth / 2) + (cardWidth / 2) // Center card on quarter position

                // Fix the parameter order: config, feature, x, y
                cards.append(generateFeatureCard(config, feature, cardX, y.toDouble()))
            }
        }

        return cards.toString()
    }

    private fun generateFeatureCard(config: RoadmapConfig, feature: RoadmapFeature, x: Double, y: Double): String {
        val cardWidth = config.displayConfig.cardWidth
        val cardHeight = config.displayConfig.cardHeight
        val category = config.categories[feature.category]
        val statusClass = feature.status.name.lowercase()

        val card = StringBuilder()

        card.append("""
        <g class="feature-card $statusClass" transform="translate($x, $y)">
    """.trimIndent())

        // Card background
        card.append("""
        <rect x="0" y="0" width="$cardWidth" height="$cardHeight" rx="12" fill="#ffffff" filter="url(#cardShadow)"/>
    """.trimIndent())

        // Category header
        val categoryColor = category?.color ?: "#6b7280"
        val categoryName = category?.name ?: feature.category

        card.append("""
        <rect x="0" y="0" width="$cardWidth" height="8" rx="12" fill="$categoryColor"/>
    """.trimIndent())

        // Priority corner badge (top-left)
        if (feature.priority != Priority.MEDIUM) {
            val priorityColor = when (feature.priority) {
                Priority.LOW -> "#10b981"
                Priority.MEDIUM -> "#f59e0b"
                Priority.HIGH -> "#f97316"
                Priority.CRITICAL -> "#ef4444"
            }
            val prioritySymbol = when (feature.priority) {
                Priority.LOW -> "L"
                Priority.MEDIUM -> "M"
                Priority.HIGH -> "H"
                Priority.CRITICAL -> "!"
            }

            card.append("""
            <polygon points="0,8 0,24 16,8" fill="$priorityColor"/>
            <text x="6" y="18" class="priority-badge">$prioritySymbol</text>
        """.trimIndent())
        }

        // Assignee initials (top-right)
        if (feature.assignee.isNotEmpty()) {
            val initials = feature.assignee.split(" ")
                .take(2)
                .map { it.first().uppercaseChar() }
                .joinToString("")

            card.append("""
            <circle cx="${cardWidth - 20}" cy="20" r="12" fill="#e5e7eb" stroke="#9ca3af" stroke-width="1"/>
            <text x="${cardWidth - 20}" y="25" class="assignee-initials">$initials</text>
        """.trimIndent())
        }

        // Category indicator circle
        card.append("""
        <circle cx="20" cy="25" r="8" fill="$categoryColor"/>
        <text x="35" y="30" class="feature-category">${categoryName.escapeXml()}</text>
    """.trimIndent())

        // Dependency indicators (small icons on right side)
        if (feature.dependencies.isNotEmpty()) {
            val depCount = feature.dependencies.size
            card.append("""
            <circle cx="${cardWidth - 40}" cy="35" r="6" fill="#f59e0b"/>
            <text x="${cardWidth - 40}" y="39" class="dependency-count">$depCount</text>
        """.trimIndent())
        }

        // Feature title with text wrapping (adjusted for top content)
        val titleStartY = 50
        val titleLines = wrapText(feature.title, cardWidth - 30, 14)
        card.append("""<text x="15" y="$titleStartY" class="feature-title">""")
        titleLines.forEachIndexed { index, line ->
            if (index == 0) {
                card.append("""<tspan x="15" dy="0">${line.escapeXml()}</tspan>""")
            } else {
                card.append("""<tspan x="15" dy="16">${line.escapeXml()}</tspan>""")
            }
        }
        card.append("""</text>""")

        // Feature description with text wrapping (adjusted for content)
        val descriptionStartY = titleStartY + (titleLines.size * 16) + 8
        val availableDescriptionHeight = cardHeight - descriptionStartY - 40 // Leave space for effort badge and release date
        val maxDescriptionLines = (availableDescriptionHeight / 14).toInt().coerceAtLeast(1)

        val allDescriptionText = feature.description.joinToString(" ")
        val descriptionLines = wrapText(allDescriptionText, cardWidth - 30, 11)
            .take(maxDescriptionLines)

        if (descriptionLines.isNotEmpty()) {
            card.append("""<text x="15" y="$descriptionStartY" class="feature-description">""")
            descriptionLines.forEachIndexed { index, line ->
                val dy = if (index == 0) "0" else "14"
                card.append("""<tspan x="15" dy="$dy">${line.escapeXml()}</tspan>""")
            }
            card.append("""</text>""")
        }

        // Effort indicator (bottom-left T-shirt size badge)
        val effortColor = when (feature.effort) {
            Effort.SMALL -> "#10b981"
            Effort.MEDIUM -> "#f59e0b"
            Effort.LARGE -> "#f97316"
            Effort.EXTRA_LARGE -> "#ef4444"
        }
        val effortSize = when (feature.effort) {
            Effort.SMALL -> "S"
            Effort.MEDIUM -> "M"
            Effort.LARGE -> "L"
            Effort.EXTRA_LARGE -> "XL"
        }

        card.append("""
        <rect x="10" y="${cardHeight - 25}" width="20" height="15" rx="3" fill="$effortColor"/>
        <text x="20" y="${cardHeight - 15}" class="effort-badge">$effortSize</text>
    """.trimIndent())

        // Release date (bottom-right)
        val releaseDateText = when (feature.status) {
            FeatureStatus.COMPLETED -> "Released: ${formatReleaseDate(feature.releaseDate)}"
            FeatureStatus.CURRENT -> "In Progress"
            FeatureStatus.PLANNED -> "Target: ${formatReleaseDate(feature.releaseDate)}"
            FeatureStatus.FUTURE -> "Target: ${formatReleaseDate(feature.releaseDate)}"
            FeatureStatus.CANCELLED -> "Cancelled"
            FeatureStatus.ON_HOLD -> "On Hold"
        }

        card.append("""
        <text x="40" y="${cardHeight - 8}" class="release-date $statusClass">$releaseDateText</text>
    """.trimIndent())

        // Status indicator (adjusted position)
        card.append(generateStatusIndicator(feature.status, categoryColor))

        // Hover tooltip with detailed information
        card.append(generateTooltip(feature, categoryName))

        card.append("</g>")

        return card.toString()
    }

    private fun generateTooltip(feature: RoadmapFeature, categoryName: String): String {
        val dependencyText = if (feature.dependencies.isNotEmpty()) {
            "Dependencies: ${feature.dependencies.joinToString(", ")}"
        } else {
            "No dependencies"
        }

        return """
        <g class="tooltip" opacity="0">
            <rect x="-10" y="-40" width="200" height="80" rx="8" fill="#1f2937" stroke="#374151" stroke-width="1"/>
            <text x="0" y="-25" class="tooltip-text">
                <tspan x="0" dy="0">Priority: ${feature.priority.name}</tspan>
                <tspan x="0" dy="12">Effort: ${feature.effort.name}</tspan>
                <tspan x="0" dy="12">Category: $categoryName</tspan>
                <tspan x="0" dy="12">$dependencyText</tspan>
            </text>
        </g>
    """.trimIndent()
    }

    private fun generateStatusIndicator(status: FeatureStatus, categoryColor: String): String {
        return when (status) {
            FeatureStatus.COMPLETED -> """
            <circle cx="135" cy="25" r="6" fill="#10b981"/>
            <path d="M 132 23 L 134 25 L 138 21" stroke="#ffffff" stroke-width="2" fill="none" stroke-linecap="round"/>
        """.trimIndent()
            FeatureStatus.CURRENT -> """
            <circle cx="135" cy="25" r="8" fill="#3b82f6" filter="url(#glow)"/>
            <circle cx="135" cy="25" r="4" fill="#ffffff"/>
        """.trimIndent()
            FeatureStatus.PLANNED -> """
            <circle cx="135" cy="25" r="6" fill="#d1d5db"/>
            <circle cx="135" cy="25" r="3" fill="#9ca3af"/>
        """.trimIndent()
            FeatureStatus.FUTURE -> """
            <circle cx="135" cy="25" r="6" fill="#f3f4f6"/>
            <circle cx="135" cy="25" r="3" fill="#d1d5db"/>
        """.trimIndent()
            else -> """
            <circle cx="135" cy="25" r="6" fill="#ef4444"/>
            <path d="M 132 22 L 138 28 M 138 22 L 132 28" stroke="#ffffff" stroke-width="2" stroke-linecap="round"/>
        """.trimIndent()
        }
    }

    private fun wrapText(text: String, maxWidth: Int, fontSize: Int): List<String> {
        if (text.isEmpty()) return emptyList()

        val words = text.split(" ")
        val lines = mutableListOf<String>()
        var currentLine = StringBuilder()

        // Approximate character width (this is a rough estimate)
        val avgCharWidth = fontSize * 0.6
        val maxCharsPerLine = (maxWidth / avgCharWidth).toInt()

        for (word in words) {
            val testLine = if (currentLine.isEmpty()) word else "${currentLine} $word"

            if (testLine.length <= maxCharsPerLine) {
                currentLine = StringBuilder(testLine)
            } else {
                if (currentLine.isNotEmpty()) {
                    lines.add(currentLine.toString())
                    currentLine = StringBuilder(word)
                } else {
                    // Word is too long, add it anyway and truncate if necessary
                    lines.add(if (word.length > maxCharsPerLine) {
                        word.substring(0, maxCharsPerLine - 3) + "..."
                    } else {
                        word
                    })
                    currentLine = StringBuilder()
                }
            }
        }

        if (currentLine.isNotEmpty()) {
            lines.add(currentLine.toString())
        }

        return lines
    }

    private fun generateLegend(config: RoadmapConfig): String {
        val legendY = config.height - 150
        val legend = StringBuilder()
        
        legend.append("""
            <g class="legend" transform="translate(50, $legendY)">
                <rect x="0" y="0" width="${config.width - 100}" height="120" rx="12" fill="#ffffff" filter="url(#cardShadow)"/>
                <text x="20" y="25" class="legend-title">Feature Categories & Status</text>
        """.trimIndent())
        
        // Categories
        legend.append("""<g class="categories" transform="translate(20, 40)">""")
        var categoryX = 0
        config.categories.values.filter { it.visible }.forEach { category ->
            legend.append("""
                <circle cx="$categoryX" cy="0" r="6" fill="${category.color}"/>
                <text x="${categoryX + 15}" y="5" class="legend-text">${category.name.escapeXml()}</text>
            """.trimIndent())
            categoryX += (category.name.length * 8) + 40
        }
        legend.append("</g>")
        
        // Status indicators
        legend.append("""
            <g class="status" transform="translate(20, 70)">
                <circle cx="0" cy="0" r="6" fill="#10b981"/>
                <path d="M -3 -1 L -1 1 L 3 -3" stroke="#ffffff" stroke-width="1.5" fill="none" stroke-linecap="round"/>
                <text x="15" y="5" class="legend-text">Completed</text>
                
                <circle cx="120" cy="0" r="8" fill="#3b82f6"/>
                <circle cx="120" cy="0" r="4" fill="#ffffff"/>
                <text x="135" y="5" class="legend-text">In Progress</text>
                
                <circle cx="240" cy="0" r="6" fill="#d1d5db"/>
                <circle cx="240" cy="0" r="3" fill="#9ca3af"/>
                <text x="255" y="5" class="legend-text">Planned</text>
                
                <circle cx="340" cy="0" r="6" fill="#f3f4f6"/>
                <circle cx="340" cy="0" r="3" fill="#d1d5db"/>
                <text x="355" y="5" class="legend-text">Future</text>
            </g>
        """.trimIndent())
        
        legend.append("</g>")
        
        return legend.toString()
    }

    private fun generateStyles(config: RoadmapConfig): String {
        val fontColor = config.displayConfig.fontColor
        val scale = config.displayConfig.scale

        return """
        <style>
            <![CDATA[
                .roadmap-title {
                    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
                    font-size: ${32 * scale}px;
                    font-weight: 700;
                    fill: $fontColor;
                    text-anchor: start;
                }
                
                .roadmap-subtitle {
                    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
                    font-size: ${16 * scale}px;
                    font-weight: 400;
                    fill: #6b7280;
                    text-anchor: start;
                }
                
                .quarter-label {
                    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
                    font-size: ${16 * scale}px;
                    font-weight: 600;
                    fill: #374151;
                    text-anchor: middle;
                }
                
                .feature-category {
                    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
                    font-size: ${9 * scale}px;
                    font-weight: 600;
                    fill: #6b7280;
                    text-anchor: start;
                    text-transform: uppercase;
                    letter-spacing: 0.5px;
                }
                
                .priority-badge {
                    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
                    font-size: ${8 * scale}px;
                    font-weight: 700;
                    fill: #ffffff;
                    text-anchor: middle;
                }
                
                .assignee-initials {
                    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
                    font-size: ${9 * scale}px;
                    font-weight: 600;
                    fill: #4b5563;
                    text-anchor: middle;
                }
                
                .dependency-count {
                    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
                    font-size: ${8 * scale}px;
                    font-weight: 700;
                    fill: #ffffff;
                    text-anchor: middle;
                }
                
                .effort-badge {
                    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
                    font-size: ${9 * scale}px;
                    font-weight: 700;
                    fill: #ffffff;
                    text-anchor: middle;
                }
                
                .feature-title {
                    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
                    font-size: ${14 * scale}px;
                    font-weight: 600;
                    fill: $fontColor;
                    text-anchor: start;
                }
                
                .feature-description {
                    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
                    font-size: ${11 * scale}px;
                    font-weight: 400;
                    fill: #6b7280;
                    text-anchor: start;
                }
                
                .release-date {
                    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
                    font-size: ${9 * scale}px;
                    font-weight: 500;
                    fill: #9ca3af;
                    text-anchor: start;
                }
                
                .release-date.current {
                    fill: #3b82f6;
                    font-weight: 600;
                }
                
                .release-date.planned {
                    fill: #f59e0b;
                }
                
                .release-date.future {
                    fill: #d1d5db;
                }
                
                .tooltip {
                    pointer-events: none;
                    transition: opacity 0.2s ease;
                }
                
                .tooltip-text {
                    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
                    font-size: ${10 * scale}px;
                    font-weight: 500;
                    fill: #ffffff;
                    text-anchor: start;
                }
                
                .legend-title {
                    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
                    font-size: ${16 * scale}px;
                    font-weight: 600;
                    fill: $fontColor;
                    text-anchor: start;
                }
                
                .legend-text {
                    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
                    font-size: ${12 * scale}px;
                    font-weight: 400;
                    fill: #6b7280;
                    text-anchor: start;
                }
                
                .feature-card {
                    cursor: pointer;
                }
                
                .feature-card rect:first-child {
                    transition: all 0.3s ease;
                }
                
                .feature-card:hover rect:first-child {
                    filter: drop-shadow(0 8px 16px rgba(0, 0, 0, 0.2));
                    transform: translateY(-3px);
                }
                
                .feature-card:hover .tooltip {
                    opacity: 1;
                }
                
                .feature-card.current circle:nth-child(7) {
                    animation: pulse 2s infinite;
                }
                
                @keyframes pulse {
                    0%, 100% { 
                        opacity: 1; 
                        transform: scale(1);
                    }
                    50% { 
                        opacity: 0.7; 
                        transform: scale(1.1);
                    }
                }
            ]]>
        </style>
    """.trimIndent()
    }
    
    private fun formatReleaseDate(dateString: String): String {
        return try {
            val date = dateFormat.parse(dateString)
            displayDateFormat.format(date)
        } catch (e: Exception) {
            dateString
        }
    }



    private fun darkenColor(hexColor: String, factor: Double): String {
        val color = hexColor.removePrefix("#")
        val r = (color.substring(0, 2).toInt(16) * (1 - factor)).toInt().coerceIn(0, 255)
        val g = (color.substring(2, 4).toInt(16) * (1 - factor)).toInt().coerceIn(0, 255)
        val b = (color.substring(4, 6).toInt(16) * (1 - factor)).toInt().coerceIn(0, 255)
        return "#%02x%02x%02x".format(r, g, b)
    }
    
    private fun lightenColor(hexColor: String, factor: Double): String {
        val color = hexColor.removePrefix("#")
        val r = (color.substring(0, 2).toInt(16) + (255 - color.substring(0, 2).toInt(16)) * factor).toInt().coerceIn(0, 255)
        val g = (color.substring(2, 4).toInt(16) + (255 - color.substring(2, 4).toInt(16)) * factor).toInt().coerceIn(0, 255)
        val b = (color.substring(4, 6).toInt(16) + (255 - color.substring(4, 6).toInt(16)) * factor).toInt().coerceIn(0, 255)
        return "#%02x%02x%02x".format(r, g, b)
    }
}

fun wrapText(text: String, width: Float): MutableList<String> {
    val words = text.trim().escapeXml().split(" ")
    var rowText = ""
    val lines = mutableListOf<String>()
    words.forEachIndexed { index, s ->
        if (rowText.length + s.length > width) {
            lines.add(rowText)
            rowText = s.trim()
        } else {
            rowText += " ${s.trim()}"
        }
    }
    if (rowText.trim().isNotEmpty()) {
        lines.add(rowText)
    }
    return lines

}

fun linesToUrlIfExist(lines: MutableList<String>, urlMap: MutableMap<String, String>): MutableList<String> {
    val newLines = mutableListOf<String>()
    lines.forEach { input ->
        var line = input
        if (input.contains("[[") && input.contains("]]")) {
            val regex = "\\[\\[(.*?)]]".toRegex()
            val matches = regex.findAll(input)

            // Process all matches in reverse order to avoid index shifting
            val matchResults = matches.toList().reversed()
            for (match in matchResults) {
                val displayText = match.groupValues[1]
                val output = urlMap["[[${displayText}]]"]
                if (output != null) {
                    val url = """<a xlink:href="$output" target="_blank" style="fill: blue; text-decoration: underline;">${displayText}</a>"""
                    // Replace only this specific occurrence
                    val startIndex = match.range.first
                    val endIndex = match.range.last + 1
                    line = line.substring(0, startIndex) + url + line.substring(endIndex)
                }
            }
        }
        newLines.add(line)
    }
    return newLines
}

fun linesToMultiLineText(lines: MutableList<String>, dy: Int, x: Int, fillColor: String?, initialY: Int = 0): String {
    var fill = ""
    fillColor?.let {
        if (fill.isNotEmpty()) {
            fill = "fill='$fillColor'"
        }
    }
    val text = StringBuilder()
    lines.forEachIndexed { i, item ->
        if (i == 0 && initialY > 0) {
            text.append("""<tspan x="$x" dy="$initialY" $fill>${item}</tspan>""")
        } else {
            text.append("""<tspan x="$x" dy="$dy" $fill>${item}</tspan>""")
        }
    }
    return text.toString()
}
