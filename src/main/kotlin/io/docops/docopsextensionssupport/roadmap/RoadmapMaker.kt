package io.docops.docopsextensionssupport.roadmap

import io.docops.docopsextensionssupport.svgsupport.escapeXml
import java.text.SimpleDateFormat

/**
 * RoadmapMaker generates SVG visualizations for feature-focused roadmaps
 * showing timeline, quarters, and feature cards with status indicators
 */
class RoadmapMaker {

    private val dateFormat = SimpleDateFormat("yyyy-MM-dd")
    private val displayDateFormat = SimpleDateFormat("MMM dd")

    fun generateRoadmapSVG(config: RoadmapConfig, features: List<RoadmapFeature>): String {
        val width = config.width
        val height = config.height
        val svg = StringBuilder()

        // Group features by quarter
        val featuresByQuarter = features.groupBy { it.quarter }

        // Calculate column counts for each quarter
        val quarterColumnCounts = config.quarters.map { quarter ->
            val quarterFeatures = featuresByQuarter[quarter] ?: emptyList()
            val maxFeaturesInColumn = 4 // Maximum features per column
            if (quarterFeatures.size > maxFeaturesInColumn) {
                kotlin.math.ceil(quarterFeatures.size.toDouble() / maxFeaturesInColumn).toInt()
            } else {
                1 // Default to 1 column if 4 or fewer features
            }
        }

        // Calculate quarter widths based on column counts
        val baseColumnWidth = 200.0
        val minQuarterWidth = baseColumnWidth // Minimum width for a quarter
        val quarterSpacing = 50.0 // Space between quarters
        val quarterWidths = quarterColumnCounts.map { columnCount ->
            maxOf(minQuarterWidth, columnCount * baseColumnWidth)
        }

        // Calculate quarter positions
        val startX = 100.0
        val quarterPositions = mutableListOf<Double>()
        var currentX = startX
        quarterWidths.forEach { width ->
            quarterPositions.add(currentX)
            currentX += width + quarterSpacing
        }

        // Calculate actual required width based on content
        val cardWidth = 160.0
        val rightMargin = 50.0
        val actualRequiredWidth = if (quarterPositions.isNotEmpty()) {
            quarterPositions.last() + quarterWidths.last() + rightMargin
        } else {
            width.toDouble()
        }

        // Use the maximum of configured width and calculated width to ensure content fits
        val finalWidth = maxOf(width.toDouble(), actualRequiredWidth).toInt()

        // SVG header
        svg.append("""
        <?xml version="1.0" encoding="UTF-8"?>
        <svg xmlns="http://www.w3.org/2000/svg" width="$finalWidth" height="$height" viewBox="0 0 $finalWidth $height">
    """.trimIndent())

        // Add metadata
        svg.append("""
        <metadata>
            <rdf:rdf xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:cc="http://creativecommons.org/ns#">
                <cc:work rdf:about="">
                    <dc:creator>DocOps.io</dc:creator>
                    <dc:rights>MIT License</dc:rights>
                    <dc:source>https://docops.io</dc:source>
                    <dc:date>2025-07-08</dc:date>
                </cc:work>
            </rdf:rdf>
        </metadata>
        <desc>Generated by DocOps.io - Licensed under MIT License</desc>
    """.trimIndent())

        // Add definitions (gradients, filters, etc.)
        svg.append(generateDefinitions(config))

        // Background
        svg.append("""
        <rect width="$finalWidth" height="$height" fill="url(#bgGradient)"/>
    """.trimIndent())

        // Header
        svg.append(generateHeader(config))

        // Timeline and quarters
        svg.append(generateTimeline(config, quarterWidths, quarterPositions))

        // Feature cards - this is the important part
        val featureCardsSection = generateFeatureCards(config, features, quarterWidths, quarterPositions)
        svg.append(featureCardsSection)

        // Legend
        if (config.showLegend) {
            svg.append(generateLegend(config, finalWidth))
        }

        // Embedded styles
        svg.append(generateStyles(config))

        svg.append("</svg>")

        return svg.toString()
    }

    private fun generateDefinitions(config: RoadmapConfig): String {
        val defs = StringBuilder()

        defs.append("<defs>")

        // Category gradients
        config.categories.forEach { (key, category) ->
            if (category.visible) {
                defs.append("""
                    <linearGradient id="${key}Gradient" x1="0%" y1="0%" x2="0%" y2="100%">
                        <stop offset="0%" style="stop-color:${category.color};stop-opacity:1" />
                        <stop offset="100%" style="stop-color:${darkenColor(category.color, 0.2)};stop-opacity:1" />
                    </linearGradient>
                """.trimIndent())
            }
        }

        // Background gradient
        defs.append("""
            <linearGradient id="bgGradient" x1="0%" y1="0%" x2="0%" y2="100%">
                <stop offset="0%" style="stop-color:${config.displayConfig.backgroundColor};stop-opacity:1" />
                <stop offset="100%" style="stop-color:${lightenColor(config.displayConfig.backgroundColor, 0.1)};stop-opacity:1" />
            </linearGradient>
        """.trimIndent())

        // Timeline gradient
        defs.append("""
            <linearGradient id="timelineGradient" x1="0%" y1="0%" x2="100%" y2="0%">
                <stop offset="0%" style="stop-color:#e5e7eb;stop-opacity:1" />
                <stop offset="40%" style="stop-color:#3b82f6;stop-opacity:1" />
                <stop offset="100%" style="stop-color:#e5e7eb;stop-opacity:1" />
            </linearGradient>
        """.trimIndent())

        // Filters
        defs.append("""
            <filter id="cardShadow" x="-50%" y="-50%" width="200%" height="200%">
                <feGaussianBlur in="SourceAlpha" stdDeviation="4"/>
                <feOffset dx="0" dy="6" result="offset" />
                <feComponentTransfer>
                    <feFuncA type="linear" slope="0.2"/>
                </feComponentTransfer>
                <feMerge> 
                    <feMergeNode/>
                    <feMergeNode in="SourceGraphic"/> 
                </feMerge>
            </filter>

            <filter id="glow" x="-50%" y="-50%" width="200%" height="200%">
                <feGaussianBlur stdDeviation="3" result="coloredBlur"/>
                <feMerge>
                    <feMergeNode in="coloredBlur"/>
                    <feMergeNode in="SourceGraphic"/>
                </feMerge>
            </filter>
        """.trimIndent())

        defs.append("</defs>")

        return defs.toString()
    }

    private fun generateHeader(config: RoadmapConfig): String {
        val titleY = 50 * config.displayConfig.scale
        val subtitleY = 75 * config.displayConfig.scale

        return """
            <text x="50" y="$titleY" class="roadmap-title">${config.title.escapeXml()}</text>
            <text x="50" y="$subtitleY" class="roadmap-subtitle">${config.subtitle.escapeXml()}</text>
        """.trimIndent()
    }

    private fun generateTimeline(config: RoadmapConfig, quarterWidths: List<Double>, quarterPositions: List<Double>): String {
        val timeline = StringBuilder()

        // Calculate positions dynamically based on quarter widths
        val startX = 100.0
        // Calculate the end position of the timeline (last quarter position + last quarter width)
        val endX = quarterPositions.last() + quarterWidths.last()

        // Generate quarter labels positioned above feature card columns
        timeline.append("""<g class="quarters">""")
        config.quarters.forEachIndexed { index, quarter ->
            // Position quarter labels at the center of each quarter
            val quarterCenter = quarterPositions[index] + (quarterWidths[index] / 2)
            timeline.append("""<text x="$quarterCenter" y="${120 * config.displayConfig.scale}" class="quarter-label">$quarter</text>""")
        }
        timeline.append("</g>")

        // Generate timeline line
        val timelineY = 140 * config.displayConfig.scale
        timeline.append("""<line x1="$startX" y1="$timelineY" x2="$endX" y2="$timelineY" stroke="url(#timelineGradient)" stroke-width="4"/>""")

        // Generate quarter markers on timeline
        config.quarters.forEachIndexed { index, _ ->
            val quarterCenter = quarterPositions[index] + (quarterWidths[index] / 2)
            timeline.append("""<circle cx="$quarterCenter" cy="$timelineY" r="6" fill="#3b82f6"/>""")
        }

        return timeline.toString()
    }

    private fun generateFeatureCards(config: RoadmapConfig, features: List<RoadmapFeature>, quarterWidths: List<Double>, quarterPositions: List<Double>): String {
        val cards = StringBuilder()

        val cardWidth = 160.0
        val cardHeight = 120.0
        val baseVerticalSpacing = 140.0
        val quarterStartY = 180.0

        // Group features by quarter
        val featuresByQuarter = features.groupBy { it.quarter }

        config.quarters.forEachIndexed { quarterIndex, quarter ->
            val quarterFeatures = featuresByQuarter[quarter] ?: emptyList()
            val quarterLeftX = quarterPositions[quarterIndex]
            val quarterWidth = quarterWidths[quarterIndex]
            val quarterCenterX = quarterLeftX + (quarterWidth / 2)

            // Calculate available space for this quarter
            val availableHeight = config.height - quarterStartY - 100 // Leave space for legend
            val maxFeaturesInColumn = 4 // Maximum features per column

            // If we have more than maxFeaturesInColumn features, arrange them in multiple columns
            if (quarterFeatures.size > maxFeaturesInColumn) {
                val columnsNeeded = kotlin.math.ceil(quarterFeatures.size.toDouble() / maxFeaturesInColumn).toInt()

                // Calculate sub-column width based on quarter width
                val subColumnWidth = quarterWidth / columnsNeeded
                val totalSubColumnsWidth = columnsNeeded * subColumnWidth
                val subColumnStartX = quarterCenterX - (totalSubColumnsWidth / 2) + (subColumnWidth / 2)

                quarterFeatures.forEachIndexed { featureIndex, feature ->
                    val columnIndex = featureIndex / maxFeaturesInColumn
                    val rowIndex = featureIndex % maxFeaturesInColumn

                    // Calculate vertical spacing for this column
                    val featuresInThisColumn = if (columnIndex == columnsNeeded - 1) {
                        // Last column might have fewer features
                        quarterFeatures.size - (columnIndex * maxFeaturesInColumn)
                    } else {
                        maxFeaturesInColumn
                    }

                    val adjustedVerticalSpacing = if (featuresInThisColumn > 1) {
                        (availableHeight / featuresInThisColumn).coerceAtLeast(cardHeight + 20).coerceAtMost(baseVerticalSpacing)
                    } else {
                        baseVerticalSpacing
                    }

                    // Position within the sub-column
                    val cardX = subColumnStartX + (columnIndex * subColumnWidth) - (cardWidth / 2)
                    val cardY = quarterStartY + (rowIndex * adjustedVerticalSpacing)

                    cards.append(generateFeatureCard(config, feature, cardX, cardY))
                }
            } else {
                // Original logic for 4 or fewer features - single column centered in quarter
                val adjustedVerticalSpacing = if (quarterFeatures.size > 1) {
                    (availableHeight / quarterFeatures.size).coerceAtLeast(cardHeight + 20).coerceAtMost(baseVerticalSpacing)
                } else {
                    baseVerticalSpacing
                }

                quarterFeatures.forEachIndexed { featureIndex, feature ->
                    val cardX = quarterCenterX - (cardWidth / 2) // Center card in quarter
                    val cardY = quarterStartY + (featureIndex * adjustedVerticalSpacing)

                    cards.append(generateFeatureCard(config, feature, cardX, cardY))
                }
            }
        }

        return cards.toString()
    }


    private fun generateFeatureCard(config: RoadmapConfig, feature: RoadmapFeature, x: Double, y: Double): String {
        val cardWidth = config.displayConfig.cardWidth
        val cardHeight = config.displayConfig.cardHeight
        val category = config.categories[feature.category]
        val statusClass = feature.status.name.lowercase()

        val card = StringBuilder()

        card.append("""
        <g class="feature-card $statusClass" transform="translate($x, $y)">
    """.trimIndent())

        // Card background
        card.append("""
        <rect x="0" y="0" width="$cardWidth" height="$cardHeight" rx="12" fill="#ffffff" filter="url(#cardShadow)"/>
    """.trimIndent())

        // Category header
        val categoryColor = category?.color ?: "#6b7280"
        val categoryName = category?.name ?: feature.category

        card.append("""
        <rect x="0" y="0" width="$cardWidth" height="8" rx="12" fill="$categoryColor"/>
    """.trimIndent())

        // Priority corner badge (top-left)
        if (feature.priority != Priority.MEDIUM) {
            val priorityColor = when (feature.priority) {
                Priority.LOW -> "#10b981"
                Priority.MEDIUM -> "#f59e0b"
                Priority.HIGH -> "#f97316"
                Priority.CRITICAL -> "#ef4444"
            }
            val prioritySymbol = when (feature.priority) {
                Priority.LOW -> "L"
                Priority.MEDIUM -> "M"
                Priority.HIGH -> "H"
                Priority.CRITICAL -> "!"
            }

            card.append("""
            <polygon points="0,8 0,24 16,8" fill="$priorityColor"/>
            <text x="6" y="18" class="priority-badge">$prioritySymbol</text>
        """.trimIndent())
        }

        // Assignee initials (top-right)
        if (feature.assignee.isNotEmpty()) {
            val initials = feature.assignee.split(" ")
                .take(2)
                .map { it.first().uppercaseChar() }
                .joinToString("")

            card.append("""
            <circle cx="${cardWidth - 20}" cy="20" r="12" fill="#e5e7eb" stroke="#9ca3af" stroke-width="1"/>
            <text x="${cardWidth - 20}" y="25" class="assignee-initials">$initials</text>
        """.trimIndent())
        }

        // Category indicator circle
        card.append("""
        <circle cx="20" cy="25" r="8" fill="$categoryColor"/>
    """.trimIndent())

        // Category name with text wrapping to prevent overflow
        val availableCategoryWidth = cardWidth - 35 - 10 // Leave 10px margin on the right
        val categoryLines = wrapText(categoryName, availableCategoryWidth.toInt(), 12)
        card.append("""<text x="35" y="30" class="feature-category">""")
        categoryLines.forEachIndexed { index, line ->
            if (index == 0) {
                card.append("""<tspan x="35" dy="0">${line.escapeXml()}</tspan>""")
            } else {
                card.append("""<tspan x="35" dy="12">${line.escapeXml()}</tspan>""")
            }
        }
        card.append("""</text>""")

        // Dependency indicators (small icons on right side)
        if (feature.dependencies.isNotEmpty()) {
            val depCount = feature.dependencies.size
            card.append("""
            <circle cx="${cardWidth - 40}" cy="35" r="6" fill="#f59e0b"/>
            <text x="${cardWidth - 40}" y="39" class="dependency-count">$depCount</text>
        """.trimIndent())
        }

        // Feature title with text wrapping (adjusted for top content)
        // Calculate titleStartY based on category text height to prevent overlap
        val categoryTextHeight = categoryLines.size * 12 // 12px per line
        val titleStartY = maxOf(50, 30 + categoryTextHeight + 8) // Ensure minimum 8px gap after category
        val titleLines = wrapText(feature.title, cardWidth - 30, 14)
        card.append("""<text x="15" y="$titleStartY" class="feature-title">""")
        titleLines.forEachIndexed { index, line ->
            if (index == 0) {
                card.append("""<tspan x="15" dy="0">${line.escapeXml()}</tspan>""")
            } else {
                card.append("""<tspan x="15" dy="16">${line.escapeXml()}</tspan>""")
            }
        }
        card.append("""</text>""")

        // Feature description with text wrapping (adjusted for content)
        val descriptionStartY = titleStartY + (titleLines.size * 16) + 8
        // Reserve more space for effort badge and release date to prevent overlap
        val bottomReservedSpace = 35 // Space for effort badge (25px height) + release date + margins
        val availableDescriptionHeight = cardHeight - descriptionStartY - bottomReservedSpace
        val maxDescriptionLines = if (availableDescriptionHeight > 14) {
            (availableDescriptionHeight / 14).toInt()
        } else {
            0 // Don't show description if no space available
        }

        val allDescriptionText = feature.description.joinToString(" ")
        val descriptionLines = wrapText(allDescriptionText, cardWidth - 30, 11)
            .take(maxDescriptionLines)

        if (descriptionLines.isNotEmpty()) {
            card.append("""<text x="15" y="$descriptionStartY" class="feature-description">""")
            descriptionLines.forEachIndexed { index, line ->
                val dy = if (index == 0) "0" else "14"
                card.append("""<tspan x="15" dy="$dy">${line.escapeXml()}</tspan>""")
            }
            card.append("""</text>""")
        }

        // Effort indicator (bottom-left T-shirt size badge)
        val effortColor = when (feature.effort) {
            Effort.SMALL -> "#10b981"
            Effort.MEDIUM -> "#f59e0b"
            Effort.LARGE -> "#f97316"
            Effort.EXTRA_LARGE -> "#ef4444"
        }
        val effortSize = when (feature.effort) {
            Effort.SMALL -> "S"
            Effort.MEDIUM -> "M"
            Effort.LARGE -> "L"
            Effort.EXTRA_LARGE -> "XL"
        }

        card.append("""
        <rect x="10" y="${cardHeight - 25}" width="20" height="15" rx="3" fill="$effortColor"/>
        <text x="20" y="${cardHeight - 15}" class="effort-badge">$effortSize</text>
    """.trimIndent())

        // Release date (bottom-right)
        val releaseDateText = when (feature.status) {
            FeatureStatus.COMPLETED -> "Released: ${formatReleaseDate(feature.releaseDate)}"
            FeatureStatus.CURRENT -> "In Progress"
            FeatureStatus.PLANNED -> "Target: ${formatReleaseDate(feature.releaseDate)}"
            FeatureStatus.FUTURE -> "Target: ${formatReleaseDate(feature.releaseDate)}"
            FeatureStatus.CANCELLED -> "Cancelled"
            FeatureStatus.ON_HOLD -> "On Hold"
        }

        card.append("""
        <text x="40" y="${cardHeight - 8}" class="release-date $statusClass">$releaseDateText</text>
    """.trimIndent())

        // Status indicator (adjusted position)
        card.append(generateStatusIndicator(feature.status, categoryColor))

        // Hover tooltip with detailed information
        card.append(generateTooltip(feature, categoryName))

        card.append("</g>")

        return card.toString()
    }

    private fun generateTooltip(feature: RoadmapFeature, categoryName: String): String {
        val dependencyText = if (feature.dependencies.isNotEmpty()) {
            "Dependencies: ${feature.dependencies.joinToString(", ")}"
        } else {
            "No dependencies"
        }

        return """
        <g class="tooltip" opacity="0">
            <rect x="-10" y="-40" width="200" height="80" rx="8" fill="#1f2937" stroke="#374151" stroke-width="1"/>
            <text x="0" y="-25" class="tooltip-text">
                <tspan x="0" dy="0">Priority: ${feature.priority.name}</tspan>
                <tspan x="0" dy="12">Effort: ${feature.effort.name}</tspan>
                <tspan x="0" dy="12">Category: $categoryName</tspan>
                <tspan x="0" dy="12">$dependencyText</tspan>
            </text>
        </g>
    """.trimIndent()
    }

    private fun generateStatusIndicator(status: FeatureStatus, categoryColor: String): String {
        return when (status) {
            FeatureStatus.COMPLETED -> """
            <circle cx="135" cy="25" r="6" fill="#10b981"/>
            <path d="M 132 23 L 134 25 L 138 21" stroke="#ffffff" stroke-width="2" fill="none" stroke-linecap="round"/>
        """.trimIndent()
            FeatureStatus.CURRENT -> """
            <circle cx="135" cy="25" r="8" fill="#3b82f6" filter="url(#glow)"/>
            <circle cx="135" cy="25" r="4" fill="#ffffff"/>
        """.trimIndent()
            FeatureStatus.PLANNED -> """
            <circle cx="135" cy="25" r="6" fill="#d1d5db"/>
            <circle cx="135" cy="25" r="3" fill="#9ca3af"/>
        """.trimIndent()
            FeatureStatus.FUTURE -> """
            <circle cx="135" cy="25" r="6" fill="#f3f4f6"/>
            <circle cx="135" cy="25" r="3" fill="#d1d5db"/>
        """.trimIndent()
            else -> """
            <circle cx="135" cy="25" r="6" fill="#ef4444"/>
            <path d="M 132 22 L 138 28 M 138 22 L 132 28" stroke="#ffffff" stroke-width="2" stroke-linecap="round"/>
        """.trimIndent()
        }
    }

    private fun wrapText(text: String, maxWidth: Int, fontSize: Int): List<String> {
        if (text.isEmpty()) return emptyList()

        val words = text.split(" ")
        val lines = mutableListOf<String>()
        var currentLine = StringBuilder()

        // Approximate character width (this is a rough estimate)
        val avgCharWidth = fontSize * 0.6
        val maxCharsPerLine = (maxWidth / avgCharWidth).toInt()

        for (word in words) {
            val testLine = if (currentLine.isEmpty()) word else "${currentLine} $word"

            if (testLine.length <= maxCharsPerLine) {
                currentLine = StringBuilder(testLine)
            } else {
                if (currentLine.isNotEmpty()) {
                    lines.add(currentLine.toString())
                    currentLine = StringBuilder(word)
                } else {
                    // Word is too long, add it anyway and truncate if necessary
                    lines.add(if (word.length > maxCharsPerLine) {
                        word.substring(0, maxCharsPerLine - 3) + "..."
                    } else {
                        word
                    })
                    currentLine = StringBuilder()
                }
            }
        }

        if (currentLine.isNotEmpty()) {
            lines.add(currentLine.toString())
        }

        return lines
    }

    private fun generateLegend(config: RoadmapConfig, svgWidth: Int): String {
        val legendY = config.height - 150
        val legend = StringBuilder()

        legend.append("""
            <g class="legend" transform="translate(50, $legendY)">
                <rect x="0" y="0" width="${svgWidth - 100}" height="120" rx="12" fill="#ffffff" filter="url(#cardShadow)"/>
                <text x="20" y="25" class="legend-title">Feature Categories & Status</text>
        """.trimIndent())

        // Categories
        legend.append("""<g class="categories" transform="translate(20, 40)">""")
        var categoryX = 0
        config.categories.values.filter { it.visible }.forEach { category ->
            legend.append("""
                <circle cx="$categoryX" cy="0" r="6" fill="${category.color}"/>
                <text x="${categoryX + 15}" y="5" class="legend-text">${category.name.escapeXml()}</text>
            """.trimIndent())
            categoryX += (category.name.length * 8) + 40
        }
        legend.append("</g>")

        // Status indicators
        legend.append("""
            <g class="status" transform="translate(20, 70)">
                <circle cx="0" cy="0" r="6" fill="#10b981"/>
                <path d="M -3 -1 L -1 1 L 3 -3" stroke="#ffffff" stroke-width="1.5" fill="none" stroke-linecap="round"/>
                <text x="15" y="5" class="legend-text">Completed</text>

                <circle cx="120" cy="0" r="8" fill="#3b82f6"/>
                <circle cx="120" cy="0" r="4" fill="#ffffff"/>
                <text x="135" y="5" class="legend-text">In Progress</text>

                <circle cx="240" cy="0" r="6" fill="#d1d5db"/>
                <circle cx="240" cy="0" r="3" fill="#9ca3af"/>
                <text x="255" y="5" class="legend-text">Planned</text>

                <circle cx="340" cy="0" r="6" fill="#f3f4f6"/>
                <circle cx="340" cy="0" r="3" fill="#d1d5db"/>
                <text x="355" y="5" class="legend-text">Future</text>
            </g>
        """.trimIndent())

        legend.append("</g>")

        return legend.toString()
    }

    private fun generateStyles(config: RoadmapConfig): String {
        val fontColor = config.displayConfig.fontColor
        val scale = config.displayConfig.scale

        return """
        <style>
            <![CDATA[
                .roadmap-title {
                    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
                    font-size: ${32 * scale}px;
                    font-weight: 700;
                    fill: $fontColor;
                    text-anchor: start;
                }

                .roadmap-subtitle {
                    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
                    font-size: ${16 * scale}px;
                    font-weight: 400;
                    fill: #6b7280;
                    text-anchor: start;
                }

                .quarter-label {
                    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
                    font-size: ${16 * scale}px;
                    font-weight: 600;
                    fill: #374151;
                    text-anchor: middle;
                }

                .feature-category {
                    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
                    font-size: ${9 * scale}px;
                    font-weight: 600;
                    fill: #6b7280;
                    text-anchor: start;
                    text-transform: uppercase;
                    letter-spacing: 0.5px;
                }

                .priority-badge {
                    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
                    font-size: ${8 * scale}px;
                    font-weight: 700;
                    fill: #ffffff;
                    text-anchor: middle;
                }

                .assignee-initials {
                    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
                    font-size: ${9 * scale}px;
                    font-weight: 600;
                    fill: #4b5563;
                    text-anchor: middle;
                }

                .dependency-count {
                    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
                    font-size: ${8 * scale}px;
                    font-weight: 700;
                    fill: #ffffff;
                    text-anchor: middle;
                }

                .effort-badge {
                    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
                    font-size: ${9 * scale}px;
                    font-weight: 700;
                    fill: #ffffff;
                    text-anchor: middle;
                }

                .feature-title {
                    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
                    font-size: ${14 * scale}px;
                    font-weight: 600;
                    fill: $fontColor;
                    text-anchor: start;
                }

                .feature-description {
                    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
                    font-size: ${11 * scale}px;
                    font-weight: 400;
                    fill: #6b7280;
                    text-anchor: start;
                }

                .release-date {
                    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
                    font-size: ${9 * scale}px;
                    font-weight: 500;
                    fill: #9ca3af;
                    text-anchor: start;
                }

                .release-date.current {
                    fill: #3b82f6;
                    font-weight: 600;
                }

                .release-date.planned {
                    fill: #f59e0b;
                }

                .release-date.future {
                    fill: #d1d5db;
                }

                .tooltip {
                    pointer-events: none;
                    transition: opacity 0.2s ease;
                }

                .tooltip-text {
                    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
                    font-size: ${10 * scale}px;
                    font-weight: 500;
                    fill: #ffffff;
                    text-anchor: start;
                }

                .legend-title {
                    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
                    font-size: ${16 * scale}px;
                    font-weight: 600;
                    fill: $fontColor;
                    text-anchor: start;
                }

                .legend-text {
                    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
                    font-size: ${12 * scale}px;
                    font-weight: 400;
                    fill: #6b7280;
                    text-anchor: start;
                }

                .feature-card {
                    cursor: pointer;
                }

                .feature-card rect:first-child {
                    transition: all 0.3s ease;
                }

                .feature-card:hover rect:first-child {
                    filter: drop-shadow(0 8px 16px rgba(0, 0, 0, 0.2));
                    transform: translateY(-3px);
                }

                .feature-card:hover .tooltip {
                    opacity: 1;
                }

                .feature-card.current circle:nth-child(7) {
                    animation: pulse 2s infinite;
                }

                @keyframes pulse {
                    0%, 100% { 
                        opacity: 1; 
                        transform: scale(1);
                    }
                    50% { 
                        opacity: 0.7; 
                        transform: scale(1.1);
                    }
                }
            ]]>
        </style>
    """.trimIndent()
    }

    private fun formatReleaseDate(dateString: String): String {
        return try {
            val date = dateFormat.parse(dateString)
            displayDateFormat.format(date)
        } catch (e: Exception) {
            dateString
        }
    }



    private fun darkenColor(hexColor: String, factor: Double): String {
        val color = hexColor.removePrefix("#")
        val r = (color.substring(0, 2).toInt(16) * (1 - factor)).toInt().coerceIn(0, 255)
        val g = (color.substring(2, 4).toInt(16) * (1 - factor)).toInt().coerceIn(0, 255)
        val b = (color.substring(4, 6).toInt(16) * (1 - factor)).toInt().coerceIn(0, 255)
        return "#%02x%02x%02x".format(r, g, b)
    }

    private fun lightenColor(hexColor: String, factor: Double): String {
        val color = hexColor.removePrefix("#")
        val r = (color.substring(0, 2).toInt(16) + (255 - color.substring(0, 2).toInt(16)) * factor).toInt().coerceIn(0, 255)
        val g = (color.substring(2, 4).toInt(16) + (255 - color.substring(2, 4).toInt(16)) * factor).toInt().coerceIn(0, 255)
        val b = (color.substring(4, 6).toInt(16) + (255 - color.substring(4, 6).toInt(16)) * factor).toInt().coerceIn(0, 255)
        return "#%02x%02x%02x".format(r, g, b)
    }
}

fun wrapText(text: String, width: Float): MutableList<String> {
    val words = text.trim().escapeXml().split(" ")
    var rowText = ""
    val lines = mutableListOf<String>()
    words.forEachIndexed { index, s ->
        if (rowText.length + s.length > width) {
            lines.add(rowText)
            rowText = s.trim()
        } else {
            rowText += " ${s.trim()}"
        }
    }
    if (rowText.trim().isNotEmpty()) {
        lines.add(rowText)
    }
    return lines

}

fun linesToUrlIfExist(lines: MutableList<String>, urlMap: MutableMap<String, String>): MutableList<String> {
    val newLines = mutableListOf<String>()
    lines.forEach { input ->
        var line = input
        if (input.contains("[[") && input.contains("]]")) {
            val regex = "\\[\\[(.*?)]]".toRegex()
            val matches = regex.findAll(input)

            // Process all matches in reverse order to avoid index shifting
            val matchResults = matches.toList().reversed()
            for (match in matchResults) {
                val displayText = match.groupValues[1]
                val output = urlMap["[[${displayText}]]"]
                if (output != null) {
                    val url = """<a xlink:href="$output" target="_blank" style="fill: blue; text-decoration: underline;">${displayText}</a>"""
                    // Replace only this specific occurrence
                    val startIndex = match.range.first
                    val endIndex = match.range.last + 1
                    line = line.substring(0, startIndex) + url + line.substring(endIndex)
                }
            }
        }
        newLines.add(line)
    }
    return newLines
}

fun linesToMultiLineText(lines: MutableList<String>, dy: Int, x: Int, fillColor: String?, initialY: Int = 0): String {
    var fill = ""
    fillColor?.let {
        if (fill.isNotEmpty()) {
            fill = "fill='$fillColor'"
        }
    }
    val text = StringBuilder()
    lines.forEachIndexed { i, item ->
        if (i == 0 && initialY > 0) {
            text.append("""<tspan x="$x" dy="$initialY" $fill>${item}</tspan>""")
        } else {
            text.append("""<tspan x="$x" dy="$dy" $fill>${item}</tspan>""")
        }
    }
    return text.toString()
}
